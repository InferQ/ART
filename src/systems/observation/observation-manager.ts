import { ObservationManager as ObservationManagerInterface, IObservationRepository } from '@/core/interfaces'; // Import the interface defined in core/interfaces
import { ObservationSocket } from '../ui/observation-socket'; // Import the class implementation
import { Observation, ObservationFilter } from '@/types'; // Kept ObservationType and Omit removed
import { generateUUID } from '@/utils/uuid'; // Assuming UUID utility exists as per Phase 0.9
import { Logger } from '@/utils/logger'; // Import Logger

/**
 * Manages the lifecycle of agent observations: creation, persistence, retrieval, and notification.
 *
 * @remarks
 * Observations are the primary way the agent reports its internal activities (intent, planning, thought process, tool execution, errors).
 * This manager provides a unified API for other systems (like `PESAgent` or `ToolSystem`) to log these events.
 * It ensures that every observation is both:
 * 1. Persisted to the configured storage (via `IObservationRepository`).
 * 2. Broadcasted to any connected UI clients (via `ObservationSocket`).
 *
 * This dual responsibility ensures that the agent's history is preserved while providing real-time feedback.
 *
 * @see {@link ObservationManagerInterface} for the interface definition.
 * @see {@link IObservationRepository} for the storage repository interface.
 */
export class ObservationManager implements ObservationManagerInterface { // Implement the imported interface
    private observationRepository: IObservationRepository;
    private observationSocket: ObservationSocket;

    /**
     * Creates an instance of ObservationManager.
     *
     * @param observationRepository The repository for persisting observations.
     * @param observationSocket The socket for notifying UI about new observations.
     */
    constructor(observationRepository: IObservationRepository, observationSocket: ObservationSocket) {
        this.observationRepository = observationRepository;
        this.observationSocket = observationSocket;
    }

    /**
     * Creates, persists, and broadcasts a new observation record based on the provided data.
     *
     * @remarks
     * This method automatically enriches the provided data with system-generated fields:
     * - `id`: A unique UUID for the observation.
     * - `timestamp`: The current system time (in ms).
     * - `title`: A default title if not provided (though specific observation types usually provide descriptive titles).
     *
     * It performs the persistence and notification in sequence. Failures in persistence will reject the promise,
     * ensuring data integrity. Failures in notification (socket errors) are logged but do not block the operation,
     * preventing UI glitches from halting agent execution.
     *
     * @param observationData An object containing the core data for the observation (`threadId`, `type`, `content`, `metadata`, etc.), excluding fields generated by the manager (`id`, `timestamp`, `title`).
     * @returns A promise that resolves when the observation has been successfully saved and notified, or rejects if a critical error occurs during persistence.
     */
    async record(observationData: Omit<Observation, 'id' | 'timestamp' | 'title'>): Promise<void> { // Corrected Omit and Promise syntax
        const observation: Observation = {
            ...observationData,
            id: generateUUID(),
            timestamp: Date.now(),
            // Generate a simple title based on the type for now if not provided
            // Ideally, the caller should provide meaningful titles for specific types
            title: `${observationData.type} Recorded`,
        };

        try {
            await this.observationRepository.addObservation(observation); // Assuming addObservation exists on IObservationRepository
            // Use the generic notify method from TypedSocket interface
            Logger.debug(`[ObservationManager] Notifying ObservationSocket for obsId: ${observation.id}, type: ${observation.type}`); // Log before notify
            this.observationSocket.notify(observation, { targetThreadId: observation.threadId });
            Logger.debug(`[ObservationManager] ObservationSocket notified for obsId: ${observation.id}`); // Log after notify
        } catch (error) {
            console.error("Error recording observation:", error);
            // Decide on error handling strategy - rethrow, log, or generate an ERROR observation?
            // For now, just logging. Consider adding an ERROR observation itself.
            throw error; // Rethrowing for now so the caller is aware
        }
    }

    /**
     * Retrieves historical observations stored for a specific thread, using the repository.
     *
     * @remarks
     * This allows the agent or UI to reconstruct the history of events for a thread.
     * It delegates the actual retrieval to the `IObservationRepository`, passing along any filter criteria.
     *
     * @param threadId The ID of the thread whose observations are to be retrieved.
     * @param filter Optional criteria (`ObservationFilter`) to filter the observations (e.g., by type, timestamp).
     * @returns A promise resolving to an array of {@link Observation} objects matching the criteria.
     * @throws If the repository encounters an error during retrieval.
     */
    async getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]> {
        try {
            // Assuming repository has a 'findObservations' method that accepts threadId and filter
            // Assuming repository has a method matching this signature
            return await this.observationRepository.getObservations(threadId, filter); // Assuming repository method is getObservations
        } catch (error) {
            console.error(`Error retrieving observations for thread ${threadId}:`, error);
            throw error; // Rethrowing for now
        }
    }
}