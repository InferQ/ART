# How to Connect Your UI to the ART Framework

This guide provides a comprehensive walkthrough for developers on how to use the ART Framework's public UI System API to build reactive and real-time user interfaces. You will learn how to access the UI sockets, subscribe to events, and fetch historical data to create a rich user experience.

## Prerequisites

Before you begin, you must complete two essential steps:

1.  **Create an `ArtInstance`**: This is the main entry point to the framework.
2.  **Set the `ThreadConfig` for a conversation**: You **must** configure each conversation thread (e.g., set the provider, model, API key, and enabled tools) *before* you can process messages or listen for events on that thread.

```javascript
import { createArtInstance, ThreadConfig } from 'art-framework';
import { artConfig } from './art.config.js'; // Your high-level instance configuration

let art;
const threadId = 'user-123-session-1'; // A unique ID for the conversation

async function initialize() {
  art = await createArtInstance(artConfig);
  
  // Define and set the configuration for the conversation thread
  const initialThreadConfig: ThreadConfig = {
    providerConfig: {
      providerName: 'openai',
      modelId: 'gpt-4o',
      adapterOptions: {
        apiKey: 'sk-your-real-openai-api-key' // Securely provide your API key
      }
    },
    enabledTools: ['CalculatorTool'],
    historyLimit: 50
  };

  await art.stateManager.setThreadConfig(threadId, initialThreadConfig);

  // Now you are ready to connect your UI for this specific threadId
}

initialize();
```

## 1. Accessing the UI System

The entry point to all UI-related functionality is the `uiSystem` object, which is a property of your `ArtInstance`.

```javascript
const uiSystem = art.uiSystem;
```

From this `uiSystem` object, you can get access to the individual sockets.

## 2. Understanding Sockets

The UI System is built on a **publish-subscribe** model. It exposes four specialized **sockets**, each acting as a dedicated channel for a specific type of data (e.g., chat messages, agent observations).

-   **Subscribing**: Your UI components can `subscribe` to a socket to listen for new data in real-time. When new data is available, a callback function you provide is executed.
-   **Unsubscribing**: Every `subscribe` call returns an `unsubscribe` function. It is crucial to call this function when your UI component unmounts to prevent memory leaks.
-   **Fetching History**: Most sockets have a `getHistory` method that allows you to retrieve a log of past data, which is essential for populating your UI when it first loads.

---

## 3. Connecting to the `ConversationSocket`

This is the most common socket, used for building chat interfaces.

### Getting the Socket

```javascript
const conversationSocket = art.uiSystem.getConversationSocket();
```

### Subscribing to New Messages

To display messages as they are sent by the user or generated by the agent, you subscribe to the socket. The callback will receive a `ConversationMessage` object.

```javascript
// Example: Displaying a new message in the chat window
const unsubscribe = conversationSocket.subscribe(
  (message) => {
    console.log('New message received:', message);
    // Code to append the message to your chat UI
    // e.g., addMessageToChat(message.content, message.role);
  },
  undefined, // No filter
  { threadId: 'user-123-session-1' } // VERY IMPORTANT: Always scope subscriptions to a thread
);

// When your component is destroyed, don't forget to unsubscribe:
// unsubscribe();
```

You can also filter messages by their role:

```javascript
// Only listen for messages from the AI
const unsubscribeFromAI = conversationSocket.subscribe(
  (message) => { /* ... */ },
  'AI', // Filter: a single MessageRole
  { threadId: 'user-123-session-1' }
);

// Only listen for messages from the USER or a TOOL
const unsubscribeFromUserOrTool = conversationSocket.subscribe(
  (message) => { /* ... */ },
  ['USER', 'TOOL'], // Filter: an array of MessageRole
  { threadId: 'user-123-session-1' }
);
```

### Fetching Message History

To load the existing chat history for a conversation, use `getHistory`.

```javascript
async function loadChatHistory(threadId) {
  try {
    const messages = await conversationSocket.getHistory(
      undefined, // No role filter
      {
        threadId: threadId,
        limit: 50 // Get the last 50 messages
      }
    );

    console.log(`Loaded ${messages.length} messages.`);
    // Code to render the historical messages in your UI
    // messages.forEach(msg => addMessageToChat(msg.content, msg.role));
  } catch (error) {
    console.error('Failed to load chat history:', error);
  }
}
```

---

## 4. Connecting to the `ObservationSocket`

This socket lets you visualize the agent's internal "thought process."

### Getting the Socket

```javascript
const observationSocket = art.uiSystem.getObservationSocket();
```

### Subscribing to New Observations

This is useful for showing a real-time feed of the agent's actions.

```javascript
// Example: Log any tool calls the agent makes
const unsubscribe = observationSocket.subscribe(
  (observation) => {
    if (observation.type === 'TOOL_CALL') {
      console.log('Agent is calling a tool:', observation.content);
      // Code to display the tool call in a "thought process" panel
    }
  },
  'TOOL_CALL', // Filter by the ObservationType
  { threadId: 'user-123-session-1' }
);

// Example: Listen for the final response to get structured UI metadata
const unsubscribeFinal = observationSocket.subscribe(
  (observation) => {
    if (observation.type === 'FINAL_RESPONSE') {
      const { message, uiMetadata } = observation.content;
      console.log('Final message:', message.content);
      console.log('UI Metadata for sources/suggestions:', uiMetadata);
      // Code to render sources and suggestions from the uiMetadata object
    }
  },
  'FINAL_RESPONSE',
  { threadId: 'user-123-session-1' }
);
```

### Fetching Observation History

You can retrieve past observations to show a complete log of a previous agent run.

```javascript
async function loadExecutionLog(threadId) {
  try {
    const observations = await observationSocket.getHistory(
      ['PLAN', 'TOOL_CALL', 'TOOL_EXECUTION', 'ERROR'], // Filter for specific types
      { threadId: threadId, limit: 100 }
    );

    console.log('Loaded execution log:', observations);
    // The `content` of the PLAN observation will be a structured array of steps.
    // The `content` of the FINAL_RESPONSE observation will contain the final message and uiMetadata.
    // Code to display the log in your UI
  } catch (error) {
    console.error('Failed to load execution log:', error);
  }
}
```

---

## 5. Connecting to the `LLMStreamSocket`

This socket is essential for creating a "typewriter" effect for the agent's response. Remember to set `stream: true` in your `art.process()` call to enable streaming.

### Getting the Socket

```javascript
const llmStreamSocket = art.uiSystem.getLLMStreamSocket();
```

### Subscribing to Stream Events

You'll typically subscribe to `TOKEN` events to append text to the UI in real-time.

```javascript
let finalMessage = '';
const unsubscribe = llmStreamSocket.subscribe(
  (streamEvent) => {
    switch (streamEvent.type) {
      case 'TOKEN':
        // v0.4.11: Differentiate between thoughts and the final response using phase-specific tokenTypes
        // THINKING tokens: PLANNING_LLM_THINKING, EXECUTION_LLM_THINKING, SYNTHESIS_LLM_THINKING
        // RESPONSE tokens: PLANNING_LLM_RESPONSE, EXECUTION_LLM_RESPONSE, SYNTHESIS_LLM_RESPONSE
        if (streamEvent.tokenType === 'SYNTHESIS_LLM_RESPONSE') {
          const token = streamEvent.data;
          finalMessage += token;
          // Code to update the last message in the UI with the new token
          // e.g., updateLastMessage(finalMessage);
        }
        break;
      case 'END':
        console.log('Stream ended. Final message:', finalMessage);
        // The stream is complete. You might save the final message to your state here.
        break;
      case 'ERROR':
        console.error('An error occurred during streaming:', streamEvent.data);
        break;
    }
  },
  undefined, // No filter
  { threadId: 'user-123-session-1' } // Scope to the correct thread
);
```

### Fetching History

The `LLMStreamSocket` does not have a `getHistory` method, as stream events are transient and not saved to the database.

---

## 6. Connecting to the `A2ATaskSocket`

This socket is for advanced applications that involve multiple agents delegating tasks to one another.

### Getting the Socket

```javascript
const a2aTaskSocket = art.uiSystem.getA2ATaskSocket();
```

### Subscribing to Task Updates

This allows you to build a real-time task management dashboard.

```javascript
// Example: Listen for any task that gets completed or fails
const unsubscribe = a2aTaskSocket.subscribe(
  (taskEvent) => {
    console.log(`Task ${taskEvent.task.taskId} moved to status: ${taskEvent.task.status}`);
    // Code to update the task's status in your dashboard UI
  },
  {
    // Rich filter object
    status: ['COMPLETED', 'FAILED']
  },
  { threadId: 'user-123-session-1' }
);
```

### Fetching Task History

You can load all existing tasks that match certain criteria.

```javascript
async function loadInProgressTasks(threadId) {
  try {
    const tasks = await a2aTaskSocket.getHistory(
      { status: 'IN_PROGRESS' }, // Filter
      { threadId: threadId }    // Options
    );

    console.log('Loaded in-progress tasks:', tasks);
    // Code to display these tasks in your UI
  } catch (error) {
    console.error('Failed to load in-progress tasks:', error);
  }
}
```

---

## 7. Visualizing Plan Changes

> **New in v0.4.15**: You can now visualize exactly how the agent's plan evolves during execution.

When the PES agent dynamically modifies its todo list (adding, modifying, or removing tasks), `PLAN_UPDATE` observations now include a `changes` field with detailed change tracking.

### Step 1: Subscribe to PLAN_UPDATE Observations

```javascript
import { ObservationType } from 'art-framework';

const observationSocket = art.uiSystem.getObservationSocket();

const unsubscribe = observationSocket.subscribe(
  (observation) => {
    if (observation.type === ObservationType.PLAN_UPDATE) {
      handlePlanUpdate(observation.content);
    }
  },
  ObservationType.PLAN_UPDATE,
  { threadId: 'user-123-session-1' }
);
```

### Step 2: Display Change Indicators

The `changes` field provides three convenience arrays for different change types:

```javascript
function handlePlanUpdate({ todoList, changes }) {
  // Show summary of changes
  console.log(
    `${changes.added.length} added, ` +
    `${changes.modified.length} modified, ` +
    `${changes.removed.length} removed`
  );

  // Update your UI with change animations
  changes.added.forEach(change => {
    showItemWithAnimation(change.item, 'slide-in');
  });

  changes.modified.forEach(change => {
    updateItemWithHighlight(
      change.itemId,
      change.item,           // New state
      change.previousItem    // Old state
    );
  });

  changes.removed.forEach(change => {
    removeItemWithAnimation(change.itemId, 'fade-out');
  });
}
```

### Step 3: Build a Change History Component

Here's a React example that accumulates and displays plan changes over time:

```javascript
import { useState, useEffect } from 'react';
import { ObservationType } from 'art-framework';

function PlanChangeHistory({ threadId }) {
  const [history, setHistory] = useState([]);

  useEffect(() => {
    const socket = art.uiSystem.getObservationSocket();

    const unsubscribe = socket.subscribe(
      (observation) => {
        if (observation.type === ObservationType.PLAN_UPDATE) {
          const { changes } = observation.content;

          // Add this batch of changes to history
          setHistory(prev => [...prev, {
            timestamp: changes.timestamp,
            added: changes.added.map(c => c.item?.description),
            modified: changes.modified.map(c => ({
              from: c.previousItem?.description,
              to: c.item?.description
            })),
            removed: changes.removed.map(c => c.previousItem?.description)
          }]);
        }
      },
      ObservationType.PLAN_UPDATE,
      { threadId }
    );

    return unsubscribe;
  }, [threadId]);

  if (history.length === 0) {
    return <div>No plan changes yet</div>;
  }

  return (
    <div className="change-history">
      <h3>Plan Evolution ({history.length} updates)</h3>
      {history.map((entry, i) => (
        <div key={i} className="change-entry">
          <span className="timestamp">
            {new Date(entry.timestamp).toLocaleTimeString()}
          </span>

          {entry.added.length > 0 && (
            <div className="added">
              + {entry.added.join(', ')}
            </div>
          )}

          {entry.modified.length > 0 && (
            <div className="modified">
              ~ {entry.modified.map(m => `${m.from} → ${m.to}`).join(', ')}
            </div>
          )}

          {entry.removed.length > 0 && (
            <div className="removed">
              - {entry.removed.join(', ')}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

### Change Types Reference

| Type | Property Access | What to Display |
|------|----------------|-----------------|
| Added | `changes.added` | `item.description` |
| Modified | `changes.modified` | `previousItem.description` → `item.description` |
| Removed | `changes.removed` | `previousItem.description` |

For more details, see [How-To: Dynamic Todolist Modifications](./pes-todolist-dynamic-modifications.md#tracking-plan-changes).

